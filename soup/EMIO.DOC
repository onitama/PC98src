
	ＥＭ（．Ｅｘｅ　ｆｉｌｅ　Ｍａｎａｇｅｒ）


◎ＥＭの構成
	EM.EXE	.EXE ファイルにファイルを格納するためのツール。
		LHA などと同じ感覚で使える（ようにしたつもり）。
		X コマンドでファイルを取り出して、ファイルをいじくって、
		A コマンドで戻す（更新する）、という使い方を想定。
	EMIO.C		プログラムから .EXE ファイル中のデータを
			アクセスするためのルーチン
	EMIO.H		ＥＭＩＯのヘッダファイル
	MSINT.ASM	ファイルアクセスに必要なルーチン
	TCS.MAC		アセンブルルーチンと Turbo-C とをつなぐためのマクロ
	MSINT.H		MSINT.ASM のＣ言語用ヘッダファイル
	ANA.H		自分がよく使う定義を格納してある。
			u_int などの型を使うのに必要。

　今は MSINT の部分はアセンブラで書いてありますが、これは別にＣ言語でも int86 などの関数を使えば充分実現可能です。なぜこの部分がアセンブラで書いてあるかと言うと、自作のｄｏｓで動かすコトをねらっていたからです。つまり、ｄｏｓを自作して、ここに書いている機能さえ備えれば、ＥＭルーチンは動くのです。もっとも .EXE ファイルはＭＳ−ＤＯＳ独自のものですが・・。


◎ＥＭの使い方

	em_init( "CM.EXE" );	/* アクセス対象とする .EXE ファイルを指定して
					イニシャライズをかける。
					ファイル名は大文字で書くこと。 */
	･･･
	em_read( buff, "NO1.ASK" );
				/* NO1.ASK を buff に読み込む。
				　buff として far 領域が可能。
				　読み込むサイズはファイルサイズと同じ。
				　読み込むのに充分な領域の確保が必要。 */
	･･･
	em_done();		/* em を終了する。必ず実行すること。 */





◎ＥＭの各ルーチンの説明

int em_init( char *exe_file_name )
　アクセス対象とする .EXE ファイルを指定してイニシャライズをかけます。ファイル名は大文字で書く必要があります（ダサくてごめんなさい）。


void em_done( void )
　ＥＭを終了します。em_init でオープンしたファイルをここでクローズするため、終了時には必ず実行してください。


void em_read( char far *buff, char *file_name )
　ファイルを buff に読み込みます。buff として far 領域が指定できます。読み込むサイズはファイルサイズと同じです。有無を言わさずファイルサイズ分読み込むので読み込むのに充分な領域の確保が必要です。



void em_write( char far *buff, char *file_name )
　buff の内容をファイルに書き込みます。すでに存在するファイルを書き換えることしかできません（新しいファイルは作れません）。書き込むサイズはファイルサイズと同じです。



u_int em_size( char *file_name )
　ファイルサイズを返します。



◎細かな仕様
　em_init では searchpath 関数を使用して、指定された .EXE ファイルを探しに行きます。searchpath は「カレントディレクトリ」→「path で指定されているディレクトリ」の順に探しに行くので、この範囲に指定した .EXE ファイルがあればちゃんとオープンします。

　em_read では通常は em_init で指定された .EXE ファイルの中だけを探して読み出します。EMIO.C の先頭にある DEVELOPING を 1 にしてコンパイルすれば、.EXE ファイルの中に無い場合には searchpath 関数を使って通常のファイルを「カレントディレクトリ」→「path で指定されているディレクトリ」の順に探しに行きます。
　例えば em_init( "CM.EXE" ); em_read( buff, "NO1.DAT" ) とした場合、通常は NO1.DAT が CM.EXE の中に無ければエラーとなりますが、DEVELOPING を 1 にしてコンパイルすれば、さらに普通の NO1.DAT というファイルを探しに行き、見つかればそれを読み込むようになります。



◎ＥＭの動作原理
　.EXE ファイルは８０８６上で６４ｋ超えるプログラムを扱うために作られた規格で、本来リロケータブルにできないプログラムを、無理矢理リロートできるようにするための規格と考えると合点がいきます。無理矢理リロケートためにはメモリにロードする際にプログラムを書き換えてしまうのがいちばん手っとり早いということで、.EXE ファイルには書き換えのためのデータが含まれています。.EXE ファイルの１バイトから逆アセンブルしてもちんぷんかんぷんなのはこの書換データなどを格納するためのヘッダがあるからです。ＭＳ−ＤＯＳエンサイクロペディアによると .EXE ファイルのヘッダの構造は次のようになっています。

	offset	size	
	0	2 bytes	識別子（'MZ' というコードが入っている）
	2	2 bytes	端数バイト
	4	2 bytes	ページ数
	･	･
	･	･（このあといろいろの情報が入っている）

　ＭＳ−ＤＯＳでは１ページは５１２バイトとなっていて、（ページ数−１）×５１２＋端数バイトでヘッダ部を含んだ .EXE ファイルの本当の大きさがわかるようになっています（ただし、端数バイトが０のときはそれを５１２とみなす）。なぜ５１２バイトかは、きっとＩＢＭのディスクが５１２バイト／セクタかなんかでフォーマットされていたからでしょう（自信なし・・）。
　で、こうして求めた .EXE ファイルのサイズは普通は実際のファイルサイズと一致するはずです。「普通は」というのは、オーバーレイなどの特別な機構が組み込まれている場合には食い違ってくるからです。
　ＭＳ−ＤＯＳは．ＥＸＥプログラムのロードの際にはヘッダに書かれた数字を見てロードするサイズを決めるので、実際のファイルサイズの方が大きい場合には、はみ出た部分は無視されるだけで害はないということになっています。

　ここで紹介する .EXE ファイルマネージャは .EXE ファイルのこの性質を利用して .EXE ファイルの後ろにどんどんデータをくっつけてしまうというプログラムなのです。


◎ＥＭのファイル管理法
　.EXE ファイルの後ろにくっつけたデータは、こちらが勝手にくっつけたものですから、その管理は当然こちらでしなければなりません。
　.EXE ファイル内ではデータは次のように格納されています。

　.EXE ファイルを本来のサイズだけ読みとばした直後からＥＭが管理するデータ領域となっています。例えば .EXE ファイルが本来 1234ﾊﾞｲﾄ の大きさだったなら、1234ﾊﾞｲﾄ 読みとばした 1235ﾊﾞｲﾄ 目からＥＭが管理するデータ領域となります。以後ここを EM-0 （EM における 0）として話を進めます。

　まず、EM-0 から４バイトはＥＭのデータであることを識別するための識別コードを置いてあります。現在は 01 01 FF FF です。これ以外のバイト列があった場合、EM.EXE や em_init() はエラーとしてこのファイルにアクセスしません。

　その次からは格納されているデータのファイル名が 00 で区切られてズラっと並んでいます。最後に 0 を２つ並べる事によってファイル名一覧部の終わりを表します。ファイル名０文字ということはあり得ないのでこれを終わりの記号としています。例えば ABC.DEF と XY.Z の２つのファイルが格納されている場合には 'ABC.DEF',0,'XY.Z',0,0 となります。

　ファイル名一覧部を見れば格納されているファイルの数が分かります。ファイル名一覧部の直後から６バイト一組でファイルの数だけファイル情報が入っています。６バイトのファイル情報の中身は次のようになっています。

	offset	size	name
	0	1 byte	pack_method	格納形式（０＝非圧縮）
	1	1 byte	reserved	未使用（予約）
	2	2 bytes	packed_len	格納されている大きさ
	4	2 bytes	org_len		本来の大きさ

　格納形式は将来圧縮したり暗号化したりする場合に備えてのものです。現在は０の非圧縮（そのまま格納）しか扱えません。格納されている大きさと本来の大きさの２通り用意してあるのも圧縮に備えてです（でも、よく考えたら圧縮をかける場合でも「本来の大きさ」をここに書き込む必要はないなあ・・・ドジ＞自分）。現在は「格納されている大きさ」と「本来の大きさは」当然同じ値なっています。
　ファイル情報の格納順序はファイル名の格納順と同じです。

　このファイル情報部が終わればあとはファイル名の格納順にファイルのイメージが入っています。

　これだけです。



◎問題点
　自分で問題点を書くのもつらいけど、今後のバージョンアップにつなげるという意味を込めて書きだしておきます。

・ファイルが長期間オープンされたままになる
　ソースを見ると分かると思うけど、なんと em_init() でオープンした .EXE ファイルは em_done() を呼ぶまでクローズされないという、トンでもなく危なっかしい設計になってます。Cattle mutilation では読み出しだけだったからいいようなものの、書き戻すことがあるアプリケーションではこの設計ではとても危ない。

・圧縮機能がない
　そこまでパワーが続かなかった・・。あとは頼む・・・＞おにたま

・その他
　「本来のファイルサイズ」は圧縮した場合だけ必要なので、現在では役にたっていません。将来圧縮が入って「圧縮率一覧」を表示するときには便利かも知れないけど・・・。ファイルデータ部の方に持っていってしまった方がよかったかもしれないなあ。ま、いいか。





/*----------------------------------------------------------------------------
	ＧＭＡＰヘルプドキュメント			1993/ver.A
	pc98 map module "gmap.h" / 1992(c)onion software/Ana./Usuaji
	'gmap.h' , 'gmap.obj'
----------------------------------------------------------------------------*/

	"GMAP" ('gmap.obj') は、PC9801用のグラフィック画面を使ったキャラクタ
	表示機能をサポートするturboＣ(++)用の制御関数群です。
	使用する場合は、画面初期化のためのgint.hも含めて、

		#include <stdio.h>
		#include <fcntl.h>
		#include <dos.h>
		#include "gint.h"		; use graphics interface
		#include "gmap.h"		; use map module
		#include "gint.inc"

	のファイルを最初にインクルードしておく必要があります。
	必ずスモールモデルでコンパイルして下さい。
	"gmap.h","gint.h"を使う場合は、5つのオブジェクトファイルもリンクします。

	例:（コマンドラインから）
		tcc -ms test.c font.obj gint.obj pal.obj aska.obj gmap.obj


	/*-------------------------------------------------------------------
		introduction
	-------------------------------------------------------------------*/

	マップモジュールGMAPは、PC9801のグラフィック画面（640×400/16color）
	上で、16×16ドット／キャラクタを基本としたマップ表示，スクロール表示，
	重ね合わせ表示を高速に処理することができます。
	また、特定の大きさの物体（32×32ドット／キャラクタ）のクリッピング，
	表示を高速に行なうソフトウエアスプライトなどの高度な処理も、Ｃ言語から
	手軽に扱うことができます。

	GMAPでは16×16ドット/16色のデータを１キャラクタとして、これを基本に
	処理を行ないます。GMAPを使うためには、まずキャラクタのデータを登録
	しておかなければなりません。登録されたキャラクタ番号を組みあわせて
	マップ表示などを行ないます。
					§
	GMAPは、単にキャラクタを組みあわせてマップ表示を行なうだけではなく、
	マップの上にさらにキャラクタを重ねて表示することができるようになって
	います。このため、GMAPでは仮想的に背景（BG画面）と前景（FG画面）に
	分けて処理しています。スクロールやマップ表示はBG画面、重ねるキャラク
	タはFG画面に割り当てられます。
	GMAPでは、BG画面，FG画面ともそれぞれ256種類のキャラクタを登録すること
	ができます。


	/*-------------------------------------------------------------------
		users guide
	-------------------------------------------------------------------*/

	まず、GMAPを使用するためには、2つのデータ領域を用意する必要があります。

		・BG画面（マップデータ）領域（最大65536ﾊﾞｲﾄ）
		・キャラクタデータ領域（最大65536ﾊﾞｲﾄ）

	BG画面（マップデータ）領域には、1ﾊﾞｲﾄ=1ｷｬﾗｸﾀとして65536ﾊﾞｲﾄまでのマップ
	情報を登録することができます。また、キャラクタデータ領域には、
	1ｷｬﾗｸﾀ=128ﾊﾞｲﾄとしてBG画面，FG画面それぞれ256ｷｬﾗｸﾀを登録することが
	できます。
	領域を確保する場合は、allocmemで行ないます。（mallocは使用不可）

	例：
		static unsigned int mapbuf;	// mapbufに先頭セグメントが入る
		if ( allocmem( 4096 , &mapbuf )!=0) { printf("メモリ不足"); };
			　　　 ^^^^
				4096×16=65536ﾊﾞｲﾄのメモリ確保

	GMAPでは、BG画面の一部をウインドゥから覗くように画面に表示させます。
	FG画面は、その上に重ねる形で40×25のサイズが最初から用意されています。
	BG画面とFG画面は完全に独立しており、BG画面をスクロールさせても、FG画面
	で指定されたキャラクタはスクロールしません。


	/*-------------------------------------------------------------------
		command reference of "gmap.h"
	-------------------------------------------------------------------*/

	◎マップモジュール初期化（その１）
		set_map( int MAP_SEG , int MAP_SX , int MAP_SY );

		int MAP_SEG	= マップデータのあるセグメントアドレス
		int MAP_SX	= マップ全体のＸ方向サイズ ( 1〜32767 )
		int MAP_SY	= マップ全体のＹ方向サイズ ( 1〜32767 )

	　マップ表示をする前に必ず実行してください。
	　BG画面（マップデータ領域）のセグメントとサイズを指定します。
	　セグメントアドレスは、あらかじめ allocmem で領域を確保しておいた
	　値になります。
	　サイズの指定はINTですが、（Ｘサイズ×Ｙサイズ）が確保した領域を
	　越えないようにしてください。


	◎マップモジュール初期化（その２）
		set_pat( int PAT_SEG , int BG_OFS , int FG_OFS );

		int PAT_SEG	= キャラクタデータのあるセグメントアドレス
		int BG_OFS	= BG画面のキャラクタデータのオフセットアドレス
		int FG_OFS	= FG画面のキャラクタデータのオフセットアドレス

	　マップ表示をする前に必ず実行してください。
	　セグメントアドレスは、あらかじめ allocmem で領域を確保しておいた
	　値になります。
	　オフセットアドレスは、セグメントアドレスから1ﾊﾞｲﾄ単位の指定に
	　なります。
	　たとえば、キャラクタデータ領域に65536ﾊﾞｲﾄ確保してあるとして、
	　先頭セグメントから256ｷｬﾗｸﾀ分をBG画面のキャラクタにすると、
	　32768ﾊﾞｲﾄがBG画面のデータにかかります。残りをFG画面で使用すると、
	　オフセットアドレスは、先頭セグメントから0〜32767が、BG画面用。
	　32768〜65535が、FG画面用になります。この例だと、指定は

			set_pat( chrbuf , 0 , 32768 );

	　になります。BG_OFSとFG_OFSを同じにすれば、BG,FGとも同じキャラクタ
	　を使用できます。メモリの消費量などを考慮して指定してください。


	◎マップモジュール初期化（その３）
		set_disp( int DISP_X , int DISP_Y , int DISP_SX , int DISP_SY );

		int DISP_X	= 画面上のマップウインドゥ左上Ｘ座標（0〜39）
		int DISP_Y	= 画面上のマップウインドゥ左上Ｙ座標（0〜24）
		int DISP_SX	= マップウインドゥＸサイズ（1〜40）
		int DISP_SY	= マップウインドゥＹザイズ（1〜25）

	　マップ表示をする前に必ず実行してください。
	　マップを画面に表示する時の位置を指定します。左上のＸＹ座標，
	　ウインドゥＸＹサイズともに、16×16ドット単位の指定になります。


	◎マップ表示（完全書き換え）
		redraw( int MAP_X , int MAP_Y );

		int MAP_X	= BG画面Ｘ座標
		int MAP_Y	= BG画面Ｙ座標

	　指定したBG画面上の座標からの状態を、マップウインドゥに表示します。
	　FG画面も同時に表示して、マップ表示を行ないます。
	　マップ表示をするためには、マップモジュールの初期化（その１〜３）を
	　行なわなければなりません。


	◎マップ表示（高速書き換え）
		update( int MAP_X , int MAP_Y );

		int MAP_X	= BG画面Ｘ座標
		int MAP_Y	= BG画面Ｙ座標

	　指定したBG画面上の座標からの状態を、マップウインドゥに表示します。
	　ただし、以前に表示した状態から変化した部分だけを書き換えるので、
	　高速に表示できます。スクロール表示などに向いています。
	　部分的に書き換えるだけなので、最初に必ずredraw関数で、全部を表示
	　させておかなければなりません。


	◎FG画面書きこみ
		putfg( int FG_X , int FG_Y , int CHAR_CODE );

		int FG_X	= FG画面Ｘ座標（0〜39）
		int FG_Y	= FG画面Ｙ座標（0〜24）
		int CHAR_CODE	= FGキャラクタコード（0〜255）

	　FG画面の指定した座標にキャラクタを書きこみます。
	　この関数では、バッファに書きこみを行なうだけで、すぐには画面は
	　変化しません。redraw，updateが実行された時に初めて画面上で変化
	　します。


	◎FG画面書きこみ(2x2)
		putfg2( int FG_X , int FG_Y , int CHAR_CODE );

		int FG_X	= FG画面Ｘ座標（0〜39）
		int FG_Y	= FG画面Ｙ座標（0〜24）
		int CHAR_CODE	= FGキャラクタコード（0〜255）

	　FG画面の指定した座標に2x2のキャラクタを書きこみます。

		putfg( X,Y,CHAR_CODE );putfg( X+1,Y,CHAR_CODE+1 );
		putfg( X,Y+1,CHAR_CODE+8 );putfg( X+1,Y+1,CHAR_CODE+9 );

	　と同じことを１つの命令で行ないます。
	　この関数では、バッファに書きこみを行なうだけで、すぐには画面は
	　変化しません。redraw，updateが実行された時に初めて画面上で変化
	　します。


	◎FG画面部分消去(2x2)
		wipfg2( int FG_X , int FG_Y );

		int FG_X	= FG画面Ｘ座標（0〜39）
		int FG_Y	= FG画面Ｙ座標（0〜24）
		int CHAR_CODE	= FGキャラクタコード（0〜255）

	　FG画面の指定した座標から2x2のキャラクタを消去します。

		putfg( X,Y,0 );putfg( X+1,Y,0 );
		putfg( X,Y+1,0 );putfg( X+1,Y+1,0 );

	　と同じことを１つの命令で行ないます。
	　この関数では、バッファに書きこみを行なうだけで、すぐには画面は
	　変化しません。redraw，updateが実行された時に初めて画面上で変化
	　します。


	◎FG画面全消去
		clrfg( int CHAR_CODE );

		int CHAR_CODE	= FGキャラクタコード（0〜255）

	　FG画面全体を指定したキャラクタコードで埋めつくします。
	　この関数では、バッファに書きこみを行なうだけで、すぐには画面は
	　変化しません。redraw，updateが実行された時に初めて画面上で変化
	　します。


	◎FG画面読みこみ
		int	getfg( int FG_X , int FG_Y );

		int FG_X	= FG画面Ｘ座標（0〜39）
		int FG_Y	= FG画面Ｙ座標（0〜24）

	　FG画面の指定した座標のキャラクタコードを読み取ります。


	◎BG画面読みこみ
		int	getbg( int BG_X , int BG_Y );

		int BG_X	= BG画面Ｘ座標
		int BG_Y	= BG画面Ｙ座標
		int CHAR_CODE	= BGキャラクタコード（0〜255）

	　BG画面の指定した座標のキャラクタコードを読み取ります。


	◎BG画面書きこみ
		putbg( int BG_X , int BG_Y , int CHAR_CODE );

		int BG_X	= BG画面Ｘ座標
		int BG_Y	= BG画面Ｙ座標
		int CHAR_CODE	= BGキャラクタコード（0〜255）

	　BG画面の指定した座標にキャラクタを書きこみます。
	　この関数では、バッファに書きこみを行なうだけで、すぐには画面は
	　変化しません。redraw，updateが実行された時に初めて画面上で変化
	　します。


	◎BG画面書きこみ(2x2)
		putbg2( int BG_X , int BG_Y , int CHAR_CODE );

		int BG_X	= BG画面Ｘ座標
		int BG_Y	= BG画面Ｙ座標
		int CHAR_CODE	= BGキャラクタコード（0〜255）

	　BG画面の指定した座標に2x2のキャラクタを書きこみます。

		putbg( X,Y,CHAR_CODE );putbg( X+1,Y,CHAR_CODE+1 );
		putbg( X,Y+1,CHAR_CODE+8 );putbg( X+1,Y+1,CHAR_CODE+9 );

	　と同じことを１つの命令で行ないます。
	　この関数では、バッファに書きこみを行なうだけで、すぐには画面は
	　変化しません。redraw，updateが実行された時に初めて画面上で変化
	　します。



	◎BG画面キャラクタ直接表示
		dputbg( int SCREEN_X , int SCREEN_Y , int CHAR_CODE );

		int SCREEN_X	= スクリーンＸ座標（0〜79）
		int SCREEN_Y	= スクリーンＹ座標（0〜399）
		int CHAR_CODE	= BGキャラクタコード（0〜255）

	　BG画面のキャラクタを画面上の指定した座標に直接表示します。
	　BG画面やFG画面とは関係なく、単に画面にキャラクタを表示します。


	◎ソフトウエアスプライト実行
		emove( int MAP_X,int MAP_Y,int EKAZZ,obj *ENEMY );

		int MAP_X	= BG画面Ｘ座標
		int MAP_Y	= BG画面Ｙ座標
		int EKAZZ	= オブジェクト数
		obj *ENEMY	= オブジェクトデータのポインタ

	　ソフトウエアスプライトの表示および移動を行ないます。
	　この関数を実行すると、FG画面をオブジェクトのデータに従って
	　書き換えて、画面表示も書き換えます。（update( MAP_X,MAP_Y )を実行
	　したのと同じ状態になる）
	　ソフトウエアスプライトの詳細については、別項を参照してください。


	/*-------------------------------------------------------------------
		data format
	-------------------------------------------------------------------*/

	GMAPで使用するキャラクタデータ，マップデータはあらかじめ作成しておき、
	seg_load命令などでキャラクタ領域に登録しなければなりません。
	キャラクタデータのフォーマットは次の通りです。

		adr:0000-001F	Bﾌﾟﾚｰﾝﾃﾞｰﾀ ････････ 各プレーンデータ
		adr:0020-003F	Rﾌﾟﾚｰﾝﾃﾞｰﾀ		 1ﾗｲﾝ L,H
		adr:0040-005F	Gﾌﾟﾚｰﾝﾃﾞｰﾀ		 2ﾗｲﾝ L,H
		adr:0060-007F	Eﾌﾟﾚｰﾝﾃﾞｰﾀ		    :
							16ﾗｲﾝ L,H

	BG画面のキャラクタはパレットコード0〜15まですべてを使用できます。
	FG画面のキャラクタのパレットコード0は透明色として処理され、背景が
	すけて見えます。したがって黒い色をFG画面で出したい場合は、1〜15の
	パレットコードのどれかに黒い色コードを割り当てておく必要があります。

	原則として、FG画面のキャラクタの最初（キャラクタコード0）は、透明
	なキャラクタ（各プレーンとも0）にしておいてください。

	BG画面のデータ（マップデータ）は、BG画面のキャラクタコードが1ﾊﾞｲﾄ
	ごとに書かれています。マップエディターなどで作成してください。


	/*-------------------------------------------------------------------
		software sprite reference
	-------------------------------------------------------------------*/

	GMAPでは、ソフトウエアスプライトドライバ（SSD ver.A）を使ってFG画面上
	のキャラクタを表示，移動させることができます。
	画面上に表示できる物体（スプライト）は4キャラクタを組み合わせた32×32
	ドットサイズのものに限られます（putfg2命令で表示されるものと同様）。
	この機能を使うためには、そのためのデータバッファを、

		static near obj ebuf[60];
				     ^^ 表示するスプライトの個数

	のように宣言しておかなければなりません。
	以降は、それぞれのスプライトのデータを次のように指定できます。

		ebuf[ 0].e_flg=1;	// 状態フラグ 0=表示しない 1=表示する
		ebuf[ 0].e_chr=32;	// FG画面キャラクタコード
		ebuf[ 0].e_xx =20;	// BG画面上のＸ座標
		ebuf[ 0].e_yy =10;	// BG画面上のＹ座標
		     ^^
		   スプライトのコード

	設定したデータ通りにFG画面を表示するには、

		emove( int MAP_X,int MAP_Y,int EKAZZ,obj *ENEMY );

	を実行させます。この命令は、update( MAP_X,MAP_Y ); も同時に実行
	されますので、あらかじめredraw命令でマップ全体を表示しておかなければ
	なりません。
	上の例で設定したスプライトを表示する場合は、

		fgclr(0); emove( 10 , 10 , 1 , ebuf );
					  ^^^  ^^^^
			　　　スプライトの個数　 データバッファ名

	を実行することでウインドゥに(10,10)の場所からの状態が表示されます。
	emove命令は、単純に現在のFG画面の上に重ねて書きこむので、新しく
	書き換える場合は、fgclr(0);を前に置いて、FG画面をクリアしてから
	emove命令を実行するようにしてください。

	スプライトのＸ，Ｙ座標はBG画面の座標系と同じになっています。つまり、
	BG画面をスクロールさせると、それと一緒にスプライトも移動します。
	これにより、スクロールするマップの中に敵が点在しているような場合でも
	自動的にクリッピングされ、表示します。


	/*-------------------------------------------------------------------
		copyright
	-------------------------------------------------------------------*/

	'gmap.h','gmap.obj'		(c)1990 T.Anazawa
	*emove (concept)		(c)1991 onitama
	*emove (programmed)		(c)1991 usuaji


/*---------------------------------------------------------------------------
	pc98 map module "gmap.h" / 1992(c)Ana./onion software/Usuaji
	Brief information of 'gmap.obj'
---------------------------------------------------------------------------*/

